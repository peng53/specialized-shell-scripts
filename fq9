#!/bin/sh
d=/mnt/ramdisk/
q=${d}mq
q_h=${d}q_hist
player_args='--pause --keep-open --really-quiet'
yt_def_args='--no-part --youtube-skip-dash-manifest --no-call-home --no-playlist'
resume=0


hist_add(){
	if [ -s $q_h ]
	then
		last=$(tail -n 1 $q_h)
		[ $last = $1 ] && return 0
	fi
	echo $1 >> $q_h
}
nx(){
	# Gets top of the top. Pops it unless there's an 1st argument.
	read -r url < $q
	[ $# -eq 0 ] && sed -i '1d;/^$/d' $q
}
arg_or_xclip(){
	[ $# -gt 0 ] && echo $1 || xclip -o 2> /dev/null
}
set_url(){
	# Sets url to either $1 or whatever on the queue.
	[ $# -gt 0 ] && url=$1 || [ -s $q ] && nx
	[ -z $url ] && exit 1
	echo 'URL:' $url
}
set_url_ax(){
	# Given an arglist, set URL if possible.
	# Sets url to either $1 or whatever on the xclipboard.
	# Special case if $url was 'hist' in which set_url_hist is used.
	url=`arg_or_xclip $@`
	[ "$url" = 'hist' ] && set_url_hist
	[ -z "$url" ] && [ -s $q ] && exit 1
	echo 'URL:' $url
}
set_url_hist(){
	# Set $url to last line of hist file if it exists.
	[ -s $q_h ] || exit 1
	url=`tail -n 1 $q_h`
}
need_resume(){
	# Sets $resume if needed.
	if [ "$1" = 'r' ]
	then
		resume=1
		echo 'Resuming download..'
		return 0
	else
		return 1
	fi
}
view_file(){
	[ -s ${d}1aud ] && dash=--audio-file=${d}1aud
	[ -s ${d}1 ] && player $player_args ${d}1 $dash &
}
overwrite_f(){
	# Overwrites filename 2nd arg at $d with 1st arg
	[ -f $d$1 ] && mv -f $d$1 $d$2
}
youtube_f_get(){
	# Uses $url $resume
	# Args are: 1-quality 2-speed 3-suffix
	[ $resume -eq 0 ] && overwrite_f 1${3} 0${3}
	echo 'Downloading at f'$1 'and s =' $2
	youtube-dl $yt_def_args -r $2 -f $1 $url -o ${d}1${3} &
}
youtube_dash(){
	# Downloads both video and audio dash versions.
	# Uses $url $resume
	youtube_f_get ${quality=242} ${speed=32K}
	sleep 10
	yt_def_args='-q '$yt_def_args
	# Next call to youtube_f_get is quiet
	printf '\n'
	youtube_f_get ${aquality=250} ${speed} aud
	sleep 20
	hist_add $url
	view_file
}
streamlink_dl(){
	# Uses $: url resume
	[ $resume -eq 0 ] && overwrite_f 1 0 && overwrite_f 1aud 0aud
	echo 'Downloading at q =' ${squality=240p}
	streamlink $url ${squality} -o ${d}1 &
	sleep 30
	hist_add $url
}
streamlink_stream(){
	# Uses $: url
	echo 'Streaming at' ${squality=240p}
	streamlink -p 'mpv --title="streamlink player"' --player-no-close --player-passthrough hls $url ${squality}
	hist_add $url
}
if [ $# -gt 0 ]
then
	case "$1" in
		add)
			shift
			set_url_ax $@
			if [ -n $url ]
			then
				echo 'Added to queue.'
				echo $url >> $q
			fi
		;;
		top)
			nx KEEP
			echo $url
		;;
		fls)
			> $q
			echo 'Queue flushed.'
		;;
		see)
			cat $q
		;;
		view)
			view_file
		;;
		halt)
			killall youtube-dl
			echo 'youtube-dl killed.'
		;;
		hist)
			cat $q_h
		;;
		ytd)
			# (resume-able)
			shift
			need_resume $1 && shift
			set_url $@
			youtube_dash
		;;
		sls)
			shift
			set_url_ax $@
			streamlink_stream
		;;
		sld)
			# (resume-able)
			shift
			need_resume $1 && shift
			set_url $@
			streamlink_dl && view_file
		;;
		*)
			echo 'Arguments not recognized'
			echo $@
		;;
	esac
else
	#echo Options were: $@
	set_url $@
	# Will only grab from queue since $1 will be blank.
	case "$url" in
		*.youtube.com/watch?v=*)
			youtube_dash
		;;
		*.crunchyroll.com/*)
			streamlink_stream
		;;
	esac
fi
